package AlgorithmStudy;

public class bitMask {
    public static void main(String[] args) {
        /**
         *  비트마스크는 정수의 이진수 표현을 사용한 방법
         *  집합의 무분 집합을 더욱 효율적으로 표현할 수 있게 해줌
         *  각 요소를 인덱스처럼 표현 i번째 요소가 부분집합에 존재하면 1 존재하지 않으면 0을 의미
         *  또한 이진수를 십진수로 표현할 수 있음
         *
         *  { 0, 1, 2, 3, 4 } => 11111 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) + (2^0 * 1) = 31
         *  { 1, 2, 3, 4 } => 11110 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) = 30
         *  { 1, 2, 4 } => 10110 => (2^4 * 1) + (2^2 * 1) + (2^1 * 1) = 22
         *  { 2, 4 } => 10100 => (2^4 * 1) + (2^2 * 1) = 20
         *  { 1 } => 00010 => (2^1 * 1) = 2
         *
         *  AND 연산(&)
         *  1010 & 1111 = 1010
         *
         *  OR 연산(|)
         *  1010 | 1111 = 1111
         *
         *  XOR 연산(^)
         *  1010 ^ 1111 = 0101
         *
         *  NOT 연산(~)
         *  ~1010 = 0101
         *
         *  Shift 연산(>>, <<)
         *  00001010 << 2 = 101000 // 왼쪽으로 2칸 이동 2의 제곱승 1, 2, 4, 8
         *  00001010 >> 2 = 000010 // 오른쪽으로 2칸 이동 2로 나눔 8, 4, 2, 1
         *
         *  삽입 연산
         *  i번째 비트의 값을 1로 변경
         *  ex) 1010 값에 i = 2를 삽입 즉, 1110을 원함, 2번째 비트를 1로 변환
         *  1010 | 1 << 2
         *  1010 | 0100 => 1110
         *
         *  삭제 연산
         *  i번째 비트의 값을 0으로 변경
         *  ex) 1110의 2번째 비트를 0으로 변경 즉, 1010을 원함
         *  1110 & ~1 << 2
         *  1110 & 1011 => 1010
         *
         *  조회 연산
         *  i번째 비트의 값을 확인
         *  A & (1 << i)
         *  2번째 비트 - 1010 & (1 << 2) = 1010 & 0100 => 0
         *  3번째 비트 - 1010 & (1 << 3) = 1010 & 1000 => 1000
         *
         **/


    }
}
